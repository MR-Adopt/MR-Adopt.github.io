"""
"""
import multiprocessing
import os, sys
import time
_PROJECT_NAME = "tool"
_CURRENT_ABSPATH = os.path.abspath(__file__)
sys.path.insert(0, _CURRENT_ABSPATH[:_CURRENT_ABSPATH.find(_PROJECT_NAME) + len(_PROJECT_NAME) + 1])

from utility import file_processing,json_processing, java_parser, java_file_processing

import config
from codebleu import calc_codebleu
import re, datetime


# naive_version
def extract_stmts_of_declaring_variables(TypeAndVariable_list, code):
    """
        Extract the statements of declaring variables from the code
        TypeAndVariable_list = [ "int a", "int b", ....]
    """
    code_of_testCase = code

    STMTs = ""
    lines_of_testCase = code_of_testCase.split("\n")
    for line_index in range(len(lines_of_testCase)):
        line = lines_of_testCase[line_index]
        if "= " not in line: continue # not varible declaration line

        for ele in TypeAndVariable_list:
            if line.strip().startswith(ele) and line.split("=")[0].strip() == ele: # 有且仅有 ele， 防止是 ele* 这种
                STMTs += f"{line}\n"
    return STMTs.strip("\n")


def find_defined_variables(code):
    # Regular expression to match typical Java variable declarations with initialization
    # This regex matches lines that start with a type name (including generic types), followed by one or more variable names separated by commas
    # and potentially initialized inline. It captures variable names initialized directly.
    pattern = re.compile(r'\b(\w+)\s+([A-Za-z_][A-Za-z0-9_]*(?:\s*,\s*[A-Za-z_][A-Za-z0-9_]*)*)\s*(?:=\s*[^;]+;|;)')
    
    # Extract all matches
    matches = pattern.findall(code)

    # Prepare to collect all distinct variable names
    defined_variables = []

    # Process each match to extract variable names
    for match in matches:
        var_type, var_names = match[0], match[1]
        # Split by commas in case of multiple variable declarations on the same line
        for var_name in var_names.split(','):
            var_name = var_name.strip()  # Clean whitespace
            if var_name:  # Check if the variable name is not empty
                defined_variables.append({"type":var_type, "name":var_name})
    return defined_variables


def find_used_variables(statement, identified_variables):
    # This will hold the names of variables that are identified as used in the statement
    used_variables = []

    # # Regex pattern to extract words that could be variable names
    # # We're looking for identifiers: sequences of word characters (letters, digits, underscores)
    # # that do not start with a digit.
    # pattern = re.compile(r'\b[A-Za-z_]\w*\b')
    # # Extract all potential variable names from the statement
    # potential_vars = pattern.findall(statement)
    # for pvar in potential_vars:
    #     for ivar in identified_variables:
    #         if ivar['name'] == pvar and ivar not in used_variables:
    #             used_variables.append(ivar)
    #             break  # Break the inner loop once a match is found

    for ivar in identified_variables:
        ivar_name = ivar["name"]
        pattern = re.compile(rf"[ ,(=]{ivar_name}[ ,).;]") # variable name should be surrounded by space, comma, equal, bracket, dot, semicolon
        used_vars = pattern.findall(statement)
        if len(used_vars)>0:
            used_variables.append(ivar)
    return used_variables


class variableDefExtractor:
    def __init__(self, code, TypeAndVariable_list_to_extract, input_generator=False, extract_code_from_MTC = True, excluded_MUTs=[]):
        """_summary_

        Args:
             extract_code_from_MTC = True, no matter this MTC is origianl or new generated.
            extract_code_from_MTC = False, it means the code is generated by LLM for constructing inputs@!
        """
        self.code = code
        self.TypeAndVariable_list_to_extract = TypeAndVariable_list_to_extract

        self.all_defined_variables = find_defined_variables(code)
        self.code_lines = code.split("\n")                    # seperated by "\\n" not  ";"
        self.variables_to_extract = variableDefExtractor.split_type_and_name(TypeAndVariable_list_to_extract)  # variables to extract [ {"name": ,"type": } ]
        self.variables_already_analyzed = []   # variables already extracted identify
        self.code_index_list_to_extract = []     # line index
        self.varible_and_its_direct_def = {}    
        self.varible_and_its_declaraction_stmt = {} # 避免重复提取，比如里面有多个 String v1 = "1.0"; / String v1 = "1.1.0"; 这种
        # print("all_defined_variables: ", self.all_defined_variables)
        self.all_relevant_variables = []
        self.all_relevant_variables.extend(self.variables_to_extract)

        self.extract_code_from_MTC = extract_code_from_MTC
        self.input_generator = None
        self.MUT_names = []
        if len(excluded_MUTs)>0:
            for invoked_methods_FQS in excluded_MUTs:
                self.MUT_names.append(invoked_methods_FQS.split("(")[0].split(".")[-1])
        if input_generator:
            self.input_generator = input_generator
            MTC_item = input_generator.MTC_item
            invoked_methods_FQSs = MTC_item["invoked_methods_FQS"]
            for invoked_methods_FQS in invoked_methods_FQSs:
                self.MUT_names.append(invoked_methods_FQS.split("(")[0].split(".")[-1])
            self.MUT_names = list(set(self.MUT_names))

            # special case: # 特殊处理了。。。
            FQS_testMethos = MTC_item["FQS_testMethos"]
            if ".testSqlDateToString()" in FQS_testMethos:
                self.MUT_names = []

    @staticmethod
    def split_type_and_name(TypeAndVariable_list_to_extract):
        varible_list = []
        for ele in TypeAndVariable_list_to_extract:
            var_name = ele.split()[-1]
            var_type = ele.rstrip(var_name).rstrip()
            varible_list.append( {"type":var_type , "name":var_name} )
        return varible_list
    
    @staticmethod
    def is_def_statement(statment, var_type, var_name, excluded_MUTs=False, extract_code_from_MTC = True):
        trimmed_line = statment.strip()
        var_type_and_name = f"{var_type} {var_name}"
        # 底线, # if MUT invocation OR assert: skip
        if trimmed_line.strip().startswith("assert") or ".assert" in trimmed_line : return False
        if extract_code_from_MTC and excluded_MUTs and len(excluded_MUTs)>0: # 当extract from original MTC, 且有excluded_MUTs时, 才不考虑MUT invocation line；如果是LLM generated code for constructing inputs，则继续提取出来～
            for MUT_name in excluded_MUTs:
                if f".{MUT_name}(" in trimmed_line or trimmed_line.strip().startswith(f"{MUT_name}("):
                    return False

        # String name = "pain";
        if (trimmed_line.startswith(var_type_and_name) and trimmed_line.split("=")[0].strip() == var_type_and_name):
            return True
        
        # symptom.addressSource(module);
        # option1: strict
        valid_prefixes = ["add", "put", "set", "update", "insert"]
        # valid_prefix_of_mutable_methods = ["add", "put", "set", "remove", "clear", "update", "delete", "insert", "append", "replace", "modify", "change", "set", "add", "remove", "delete", "insert", "append", "replace", "modify", "change"]
        """_summary_
                ke: addressSource, filter2.add(mockEvent2);, map.put(key, value);
                buke: $MUT,  onSet, getSymptomLastUpdatedTime
        """
        for valid_prefix in valid_prefixes:
            if trimmed_line.startswith(f"{var_name}.{valid_prefix}"):
                return True
        # # option2: loose, will not be 
        # if trimmed_line.startswith(f"{var_name}."):
        #     return True

        # Arrays.fill(lts, now); "lts" is the source input 
        valid_functions = ["Arrays.fill"]
        for valid_function in valid_functions:
            if trimmed_line.startswith(f"{valid_function}({var_name}"):
                return True

        # lts[0] = xxx ; lts.xx = xxx
        if "=" in trimmed_line and var_name in trimmed_line.split("=")[0]:
            eql_symbole_trimmed_line = trimmed_line.split("=")[0]
            pattern = re.compile(rf'{var_name}[.[]')
            matches = pattern.findall(eql_symbole_trimmed_line)
            if len(matches)>0:
                return True
        return False
    

    @staticmethod
    def is_var_declaration_statement(statment, var_type, var_name):
        trimmed_line = statment.strip()
        var_type_and_name = f"{var_type} {var_name}"
        # String name = "pain";
        if (trimmed_line.startswith(var_type_and_name) and trimmed_line.split("=")[0].strip() == var_type_and_name):
            return True
        return False

    def extract_variable_def_code(self):
        extracted_code = ""
        self.identify_variable_def_code_line()
        
        extracted_code= ""
        self.code_index_list_to_extract = sorted(list(set(self.code_index_list_to_extract)))
        for code_line_index in self.code_index_list_to_extract:
            extracted_code += self.code_lines[code_line_index] + "\n"
        return extracted_code.strip("\n")

    def get_all_relevant_variables(self):
        self.extract_variable_def_code()
        return self.all_relevant_variables

    def identify_variable_def_code_line(self):
        # print("variables_to_extract: ", self.variables_to_extract)

        # Prepare a regex to match variable declarations and method calls for the given variables.
        # declaration_index_range = range(len(self.variables_to_extract))
        # for declaration_index in declaration_index_range: # self.variables_to_extract 会波动。。
        while len(self.variables_to_extract)>0:
            # profile
            declaration = self.variables_to_extract[0] # 每次都取第一个
            var_type, var_name = declaration["type"], declaration["name"] # var_type, var_name = declaration.split()[-2], declaration.split()[-1]
            self.variables_already_analyzed.append(declaration)
            self.variables_to_extract.remove(declaration)
            var_type_and_name = f"{var_type} {var_name}"
            if var_type_and_name not in self.varible_and_its_direct_def:
                self.varible_and_its_direct_def[var_type_and_name] = []


            for line_index in range(len(self.code_lines)):
                line = self.code_lines[line_index]
                # is_def_statement
                # if pattern_declaration.match(trimmed_line) or ( pattern_method_call.match(trimmed_line)):
                if variableDefExtractor.is_def_statement(line, var_type, var_name, self.MUT_names, self.extract_code_from_MTC):
                    # 避免重复: is varible declaration, 只能有一次。。。
                    if variableDefExtractor.is_var_declaration_statement(line, var_type, var_name):
                        if var_type_and_name not in self.varible_and_its_declaraction_stmt:
                            self.varible_and_its_declaraction_stmt[var_type_and_name] = line
                        else: continue  

                    self.varible_and_its_direct_def[var_type_and_name].append(line)
                    if line_index not in self.code_index_list_to_extract: 
                        self.code_index_list_to_extract.append(line_index)
                        # suffix of the end of a statement in Java code
                        suffix_of_end = [";", "}"]
                        # 持续提取，直到遇到分号或者大括号为止
                        line_to_extract = self.code_lines[line_index]; line_to_extract_index = line_index
                        while not line_to_extract.endswith(";") and not line_to_extract.endswith("}") and line_to_extract_index<len(self.code_lines)-1:
                            print("NOTE: this line no end: ", line_to_extract, self.code)
                            line_to_extract_index = line_to_extract_index + 1
                            line_to_extract = self.code_lines[line_to_extract_index]
                            if line_to_extract_index not in self.code_index_list_to_extract: 
                                self.code_index_list_to_extract.append(line_to_extract_index)
                            else: break
                    else: continue
                            
                    
                    # sub_varibles
                    sub_varibles = find_used_variables(line, self.all_defined_variables)
                    for sub_var in sub_varibles:
                        if sub_var not in self.variables_already_analyzed:
                            self.variables_to_extract.append(sub_var)
                            self.all_relevant_variables.append(sub_var)
                    # print("line: ", line)
                    # print("variables_to_extract: ", self.variables_to_extract)

                    if len(self.variables_to_extract)>0:
                        self.identify_variable_def_code_line()
                    

def split_code_into_statements(code):
    statements = []
    current_statement = []
    in_string = False  # Flag to track if the current character is within a string literal
    escape = False  # Flag to track escaping characters within strings

    for char in code:
        if char == '"' and not escape:  # Toggle the in_string flag if a quote is found and it's not escaped
            in_string = not in_string
        elif char == '\\' and in_string:  # If we encounter a backslash in a string, toggle the escape flag
            escape = not escape
            current_statement.append(char)
            continue  # Continue to the next character to handle the escaping properly
        elif char == ';' and not in_string:  # If a semicolon is found outside of strings, end the current statement
            current_statement.append(char)
            statements.append(''.join(current_statement).strip())
            current_statement = []
            escape = False  # Reset the escape flag
            continue  # Skip to the next character
        elif char == '\n' and not in_string:  # Ignore newlines outside of strings for statement splitting
            escape = False  # Reset the escape flag
            continue  # Skip to the next character

        # Add the current character to the statement and reset escape if it was not used
        current_statement.append(char)
        escape = False

    # Append any remaining code as the last statement if not empty
    if current_statement:
        statements.append(''.join(current_statement).strip())

    return statements


# code_example = """
# @Test
# public void testExpressedSymtpom() {
#     String name = "pain";
#     ExpressedSymptom symptom = new ExpressedSymptom(name);
#     String module = "testModule";
#     symptom.addressSource(module);
#     ExpressedSymptom symptom2 = symptom;
#     String module2 = "testModule";
#     symptom2.addressSource(module2);
#     String cause = "testCause";
#     for (long l = 0L; l < 3L; l++) {
#         symptom.onSet(module, cause, l, (int) (100 * l), false);
#         assertEquals(Long.valueOf(l), symptom.getSymptomLastUpdatedTime(module2));
#     }
# }
# """

# variables  = ["ExpressedSymptom symptom"]

# print( variableDefExtractor(code_example, variables).extract_variable_def_code() )
