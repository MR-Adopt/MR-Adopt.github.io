[
    {
        "role": "system",
        "content": "As an expert in Java programming, you excel at understanding the intentions behind code and developing functions that convert provided inputs into desired outputs.\nIn metamorphic testing, input transformation functions are crafted to automatically generate additional test inputs (denoted as 'FOLLOW UP INPUT') from initial test inputs (denoted as 'SOURCE INPUT') based on defined metamorphic relations (MRs).\n\nGiven the program under test (denoted as 'METHOD UNDER TEST'), an MR-encoded test case (denoted as 'TEST CASE'),\nand additional pairs of 'SOURCE INPUT' and 'FOLLOW UP INPUT' (denoted as 'OTHER INPUT PAIRS'),\\\nyour task is to analyze the program under test and the provided test case, deduce the relationship between 'SOURCE INPUT' and 'FOLLOW UP INPUT' in the test case, and create a function that transforms 'SOURCE INPUT' into 'FOLLOW UP INPUT'.\n\nThe deduced relation and generated transformation function should be applicable to addtional input pairs and other potentail input pairs with similar characteristics.\nConsidering potential input pairs with boundary values as well.\n"
    },
    {
        "role": "user",
        "content": "# METHOD UNDER TEST\n```java\n/**\n * Calculates the minimum number of segments that should be considered for\n * moving in a tier, so that the cluster is always balancing itself.\n * <p>\n * This value must be calculated separately for every tier.\n *\n * @param totalSegmentsInTier Total number of all replicas of all segments\n *                            loaded or queued across all historicals in the tier.\n * @return {@code minSegmentsToMoveInTier} in the range\n * [{@link #MIN_SEGMENTS_TO_MOVE}, {@code ~0.15% of totalSegmentsInTier}].\n */\npublic static int computeMinSegmentsToMoveInTier(int totalSegmentsInTier) {\n    // Divide by 2^14 and multiply by 100 so that the value increases\n    // in steps of 100 for every 2^16 = ~65k segments\n    int upperBound = (totalSegmentsInTier >> 16) * 100;\n    int lowerBound = Math.min(MIN_SEGMENTS_TO_MOVE, totalSegmentsInTier);\n    return Math.max(lowerBound, upperBound);\n}\n\n/**\n * Calculates the number of segments to be picked for moving in the given tier,\n * based on the level of skew between the historicals in the tier.\n *\n * @param tier                    Name of tier used for logging purposes\n * @param historicals             Active historicals in tier\n * @param maxSegmentsToMoveInTier Maximum number of segments allowed to be moved\n *                                in the tier.\n * @return Number of segments to move in the tier in the range\n * [{@link #MIN_SEGMENTS_TO_MOVE}, {@code maxSegmentsToMoveInTier}].\n */\npublic static int computeNumSegmentsToMoveInTier(String tier, List<ServerHolder> historicals, int maxSegmentsToMoveInTier) {\n    final int totalSegments = historicals.stream().mapToInt(server -> server.getProjectedSegments().getTotalSegmentCount()).sum();\n    // Move at least some segments to ensure that the cluster is always balancing itself\n    final int minSegmentsToMove = SegmentToMoveCalculator.computeMinSegmentsToMoveInTier(totalSegments);\n    final int segmentsToMoveToFixDeviation = SegmentToMoveCalculator.computeNumSegmentsToMoveToBalanceTier(tier, historicals);\n    log.info(\"Need to move [%,d] segments in tier[%s] to attain balance. Allowed values are [min=%d, max=%d].\", segmentsToMoveToFixDeviation, tier, minSegmentsToMove, maxSegmentsToMoveInTier);\n    final int activeSegmentsToMove = Math.max(minSegmentsToMove, segmentsToMoveToFixDeviation);\n    return Math.min(activeSegmentsToMove, maxSegmentsToMoveInTier);\n}\n\n```\n\n\n# TEST CASE\n```java\n@Test\npublic void testMinSegmentsArePickedForMoveWhenNoSkew() {\n    int totalSegmentsInTier = 20_000;\n    String tier = \"tier1\";\n    List<ServerHolder> historicals = Arrays.asList(createServer(\"A\", SegmentToMoveCalculatorTest.WIKI_SEGMENTS), createServer(\"B\", SegmentToMoveCalculatorTest.WIKI_SEGMENTS));\n    int maxSegmentsToMoveInTier = Integer.MAX_VALUE;\n    int minSegmentsToMove = SegmentToMoveCalculator.computeMinSegmentsToMoveInTier(totalSegmentsInTier);\n    // Find segmentsToMove with no limit on maxSegmentsToMove\n    int segmentsToMove = SegmentToMoveCalculator.computeNumSegmentsToMoveInTier(tier, historicals, maxSegmentsToMoveInTier);\n    // System.out.println(\"minSegmentsToMove: \" + minSegmentsToMove);\n    // System.out.println(\"segmentsToMove: \" + segmentsToMove);\n    Assert.assertEquals(minSegmentsToMove, segmentsToMove);\n}\n\n```\nSOURCE INPUT: `totalSegmentsInTier`\nFOLLOW UP INPUT: `tier`,`historicals`,`maxSegmentsToMoveInTier`\n\n\n# OTHER INPUT PAIRS \n\n\n\n# OUTPUT FORMAT\n```java\npublic class SegmentToMoveCalculatorTest_testMinSegmentsArePickedForMoveWhenNoSkew {\n    public static List<Object> inputTransformation_testMinSegmentsArePickedForMoveWhenNoSkew(int totalSegmentsInTier)  {\n        // TODO\n        String tier = \n\t\tList<ServerHolder> historicals = \n\t\tint maxSegmentsToMoveInTier = \n\t\tList<Object> transformed_inputs = Arrays.asList(tier, historicals, maxSegmentsToMoveInTier);\n\t\treturn transformed_inputs;\n    }\n}\n```\nYour task is to deduce the relationship between 'SOURCE INPUT' and 'FOLLOW UP INPUT' in the test case, and create a function that transforms 'SOURCE INPUT' into 'FOLLOW UP INPUT'.\nThe deduced relation and generated transformation function should be applicable to addtional input pairs and other potentail input pairs with similar characteristics.\nGenerate the transformation function by complementing the above code skeleton in 'OUTPUT FORMAT'."
    }
]